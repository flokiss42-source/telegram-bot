import logging
import requests
import pandas as pd
import numpy as np
import asyncio
import random
import sqlite3
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes, MessageHandler, filters

# === –ù–ê–°–¢–†–û–ô–ö–ò ===
import os
BOT_TOKEN = os.getenv('BOT_TOKEN', "7680262994:AAECsRUEeFjnBpq0xLT9Ff4k1Dz9uAJeZ64")

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ==================== NFT –°–ò–°–¢–ï–ú–ê ====================
class ExclusiveNFTSystem:
    def __init__(self):
        self.owner_id = 6524964030
        self.owner_username = "@beyondbesdey"
        self.user_stars = {}
        self.nft_collections = self._initialize_nft_collections()
        self.user_nfts = {}
        self.star_transactions = []
        
    def _initialize_nft_collections(self):
        return {
            'death_note_relics': {
                'name': 'üìñ –†–µ–ª–∏–∫–≤–∏–∏ –¢–µ—Ç—Ä–∞–¥–∏ –°–º–µ—Ä—Ç–∏',
                'items': {
                    'death_note_page': {
                        'name': '–°—Ç—Ä–∞–Ω–∏—Ü–∞ –¢–µ—Ç—Ä–∞–¥–∏ –°–º–µ—Ä—Ç–∏',
                        'price': 50,
                        'rarity': 'LEGENDARY',
                        'description': '–ü–æ–¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –∏–∑ –¢–µ—Ç—Ä–∞–¥–∏ –°–º–µ—Ä—Ç–∏',
                        'benefits': ['+50% –∫ –Ω–∞–≥—Ä–∞–¥–∞–º –∑–∞ –∑–∞–ø–∏—Å–∏'],
                        'stock': 100,
                        'image': 'üìú'
                    },
                    'shinigami_eyes': {
                        'name': 'üëÅÔ∏è –ì–ª–∞–∑–∞ –®–∏–Ω–∏–≥–∞–º–∏',
                        'price': 100,
                        'rarity': 'MYTHIC', 
                        'description': '–í–∏–¥–µ—Ç—å –∏–º–µ–Ω–∞ –∏ —Å—Ä–æ–∫–∏ –∂–∏–∑–Ω–∏ —Å–º–µ—Ä—Ç–Ω—ã—Ö',
                        'benefits': ['+100% –∫ –Ω–∞–≥—Ä–∞–¥–∞–º –∑–∞ —Ü–µ–ª–∏'],
                        'stock': 50,
                        'image': 'üëÅÔ∏è'
                    }
                }
            },
            'kira_legacy': {
                'name': '‚ö° –ù–∞—Å–ª–µ–¥–∏–µ –ö–∏—Ä–∞',
                'items': {
                    'kira_mask': {
                        'name': 'üé≠ –ú–∞—Å–∫–∞ –ö–∏—Ä–∞', 
                        'price': 75,
                        'rarity': 'LEGENDARY',
                        'description': '–õ–µ–≥–µ–Ω–¥–∞—Ä–Ω–∞—è –º–∞—Å–∫–∞ —Å–∞–º–æ–≥–æ –ö–∏—Ä–∞',
                        'benefits': ['+2 —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Ç–µ—Ç—Ä–∞–¥–∏'],
                        'stock': 25,
                        'image': 'üé≠'
                    }
                }
            }
        }

    def add_stars(self, user_id, stars_count):
        if user_id not in self.user_stars:
            self.user_stars[user_id] = 0
        self.user_stars[user_id] += stars_count
        return True

    def get_user_stars(self, user_id):
        return self.user_stars.get(user_id, 0)

    def get_nft_marketplace(self):
        text = "üé¥ <b>–≠–ö–°–ö–õ–Æ–ó–ò–í–ù–´–ô NFT –ú–ê–†–ö–ï–¢–ü–õ–ï–ô–°</b>\n\n"
        text += f"üí´ <b>–í–ª–∞–¥–µ–ª–µ—Ü:</b> {self.owner_username}\n"
        text += "‚≠ê <b>–í–∞–ª—é—Ç–∞:</b> Telegram Stars\n\n"
        
        for collection_id, collection in self.nft_collections.items():
            text += f"üìÇ <b>{collection['name']}</b>\n"
            for item_id, item in collection['items'].items():
                text += f"{item['image']} <b>{item['name']}</b>\n"
                text += f"   üí∞ {item['price']} –∑–≤–µ–∑–¥ | üéØ {item['rarity']}\n"
                text += f"   üì¶ {item['stock']} —à—Ç. | üí° {item['description']}\n\n"
        
        text += "üîÆ <b>–ö–∞–∫ –∫—É–ø–∏—Ç—å:</b>\n"
        text += f"1. –ù–∞–ø–∏—à–∏—Ç–µ {self.owner_username}\n"
        text += "2. –û—Ç–ø—Ä–∞–≤—å—Ç–µ Stars –≤ Telegram\n"
        text += "3. –ü–æ–ª—É—á–∏—Ç–µ NFT!\n"
        return text

    def purchase_nft(self, user_id, collection_id, item_id):
        if collection_id not in self.nft_collections:
            return False, "‚ùå –ö–æ–ª–ª–µ–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
        
        nft_item = self.nft_collections[collection_id]['items'][item_id]
        user_stars = self.user_stars.get(user_id, 0)
        
        if user_stars < nft_item['price']:
            return False, f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–≤–µ–∑–¥. –ù—É–∂–Ω–æ: {nft_item['price']}"
        
        if nft_item['stock'] <= 0:
            return False, "‚ùå NFT —Ä–∞—Å–ø—Ä–æ–¥–∞–Ω"
        
        self.user_stars[user_id] -= nft_item['price']
        nft_item['stock'] -= 1
        
        if user_id not in self.user_nfts:
            self.user_nfts[user_id] = []
            
        nft_data = {
            'id': f"{collection_id}_{item_id}",
            'name': nft_item['name'],
            'rarity': nft_item['rarity'],
            'image': nft_item['image'],
            'benefits': nft_item['benefits']
        }
        
        self.user_nfts[user_id].append(nft_data)
        return True, nft_data

    def get_user_nfts(self, user_id):
        return self.user_nfts.get(user_id, [])

# ==================== –£–õ–£–ß–®–ï–ù–ù–´–ô –ê–ù–ê–õ–ò–ó–ê–¢–û–† –†–´–ù–ö–ê ====================
class AdvancedMarketAnalyzer:
    def __init__(self):
        self.top_cryptos = [
            'bitcoin', 'ethereum', 'binancecoin', 'ripple', 'cardano', 
            'solana', 'polkadot', 'dogecoin', 'avalanche-2', 'matic-network',
            'litecoin', 'chainlink', 'cosmos', 'stellar', 'bitcoin-cash',
            'monero', 'ethereum-classic', 'filecoin', 'theta-token', 'aave'
        ]
    
    def get_detailed_crypto_data(self, symbol):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–µ—Ç–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö —Å –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤"""
        try:
            url = f"https://api.coingecko.com/api/v3/coins/{symbol}"
            params = {
                'localization': 'false',
                'tickers': 'true',
                'market_data': 'true',
                'community_data': 'true',
                'developer_data': 'true',
                'sparkline': 'true'
            }
            response = requests.get(url, params=params, timeout=20)
            if response.status_code == 200:
                return response.json()
            return None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö {symbol}: {e}")
            return None
    
    def calculate_advanced_indicators(self, market_data):
        """–†–∞—Å—á–µ—Ç –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã—Ö —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤"""
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞
            prices = market_data.get('sparkline_in_7d', {}).get('price', [])
            if len(prices) < 10:
                return self._generate_fallback_indicators()
            
            df = pd.DataFrame(prices, columns=['price'])
            
            # RSI
            delta = df['price'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            rs = gain / loss
            rsi = 100 - (100 / (1 + rs)).iloc[-1] if not rs.isna().all() else 50
            
            # –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å (ATR)
            high = df['price'].rolling(window=14).max()
            low = df['price'].rolling(window=14).min()
            atr = ((high - low) / df['price'] * 100).iloc[-1] if not high.isna().all() else 5
            
            # –¢—Ä–µ–Ω–¥–æ–≤—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
            sma_20 = df['price'].rolling(window=20).mean().iloc[-1]
            sma_50 = df['price'].rolling(window=50).mean().iloc[-1]
            trend = "üü¢ –í–û–°–•–û–î–Ø–©–ò–ô" if sma_20 > sma_50 else "üî¥ –ù–ò–°–•–û–î–Ø–©–ò–ô" if sma_20 < sma_50 else "üü° –ë–û–ö–û–í–û–ô"
            
            # –£—Ä–æ–≤–Ω–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∏ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è
            resistance = df['price'].tail(20).max()
            support = df['price'].tail(20).min()
            current_price = df['price'].iloc[-1]
            
            return {
                'rsi': round(rsi, 1),
                'volatility': round(atr, 2),
                'trend': trend,
                'sma_20': round(sma_20, 2),
                'sma_50': round(sma_50, 2),
                'resistance': round(resistance, 2),
                'support': round(support, 2),
                'distance_to_resistance': round(((resistance - current_price) / current_price * 100), 1),
                'distance_to_support': round(((current_price - support) / current_price * 100), 1)
            }
        except:
            return self._generate_fallback_indicators()
    
    def _generate_fallback_indicators(self):
        """–†–µ–∑–µ—Ä–≤–Ω—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –µ—Å–ª–∏ API –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç"""
        return {
            'rsi': random.randint(30, 70),
            'volatility': random.uniform(2, 15),
            'trend': random.choice(["üü¢ –í–û–°–•–û–î–Ø–©–ò–ô", "üî¥ –ù–ò–°–•–û–î–Ø–©–ò–ô", "üü° –ë–û–ö–û–í–û–ô"]),
            'sma_20': 0,
            'sma_50': 0,
            'resistance': 0,
            'support': 0,
            'distance_to_resistance': 0,
            'distance_to_support': 0
        }
    
    def generate_comprehensive_analysis(self, symbol):
        """–ö–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–æ–Ω–Ω—ã–º–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è–º–∏"""
        data = self.get_detailed_crypto_data(symbol)
        
        if not data:
            return self._generate_fallback_analysis(symbol)
        
        market_data = data.get('market_data', {})
        current_price = market_data.get('current_price', {}).get('usd', 0)
        price_change_24h = market_data.get('price_change_percentage_24h', 0)
        price_change_7d = market_data.get('price_change_percentage_7d', 0)
        market_cap = market_data.get('market_cap', {}).get('usd', 0)
        volume_24h = market_data.get('total_volume', {}).get('usd', 0)
        
        indicators = self.calculate_advanced_indicators(market_data)
        
        return self._build_comprehensive_analysis(
            symbol, current_price, price_change_24h, price_change_7d,
            market_cap, volume_24h, indicators, data
        )
    
    def _build_comprehensive_analysis(self, symbol, current_price, price_change_24h, price_change_7d, 
                                    market_cap, volume_24h, indicators, raw_data):
        """–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞"""
        display_symbol = symbol.upper().replace('-', ' ').title()
        
        # –ê–Ω–∞–ª–∏–∑ —Ä–∏—Å–∫–æ–≤
        risk_score = self._calculate_risk_score(price_change_24h, indicators['volatility'], market_cap)
        
        # –ò–Ω–≤–µ—Å—Ç–∏—Ü–∏–æ–Ω–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è
        strategy = self._generate_investment_strategy(indicators, risk_score, price_change_24h)
        
        # –¢–æ—Ä–≥–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã
        signals = self._generate_trading_signals(indicators, price_change_24h)
        
        return {
            'symbol': display_symbol,
            'current_price': current_price,
            'price_change_24h': price_change_24h,
            'price_change_7d': price_change_7d,
            'market_cap': market_cap,
            'volume_24h': volume_24h,
            'indicators': indicators,
            'risk_score': risk_score,
            'strategy': strategy,
            'signals': signals,
            'timestamp': datetime.now()
        }
    
    def _calculate_risk_score(self, price_change, volatility, market_cap):
        """–†–∞—Å—á–µ—Ç –æ—Ü–µ–Ω–∫–∏ —Ä–∏—Å–∫–∞"""
        score = 0
        
        # –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å (0-40 points)
        if volatility > 20: score += 40
        elif volatility > 15: score += 30
        elif volatility > 10: score += 20
        elif volatility > 5: score += 10
        
        # –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã (0-30 points)
        if abs(price_change) > 15: score += 30
        elif abs(price_change) > 10: score += 20
        elif abs(price_change) > 5: score += 10
        
        # –ö–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è (0-30 points)
        if market_cap < 100000000: score += 30  # < 100M
        elif market_cap < 1000000000: score += 20  # < 1B
        elif market_cap < 10000000000: score += 10  # < 10B
        
        return min(score, 100)
    
    def _generate_investment_strategy(self, indicators, risk_score, price_change):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–æ–Ω–Ω–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏"""
        strategies = []
        
        # –°—Ç—Ä–∞—Ç–µ–≥–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ RSI
        if indicators['rsi'] < 30:
            strategies.append("üìâ RSI –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç—å - —Ö–æ—Ä–æ—à–∞—è —Ç–æ—á–∫–∞ –¥–ª—è –≤—Ö–æ–¥–∞")
        elif indicators['rsi'] > 70:
            strategies.append("üìà RSI –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç—å - –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ—Å—Ç—å —Å –ø–æ–∫—É–ø–∫–∞–º–∏")
        
        # –°—Ç—Ä–∞—Ç–µ–≥–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç—Ä–µ–Ω–¥–∞
        if "–í–û–°–•–û–î–Ø–©–ò–ô" in indicators['trend']:
            strategies.append("üü¢ –¢—Ä–µ–Ω–¥ –≤–æ—Å—Ö–æ–¥—è—â–∏–π - —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–π—Ç–µ –ø–æ–∫—É–ø–∫–∏ –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ü–∏—è—Ö")
        elif "–ù–ò–°–•–û–î–Ø–©–ò–ô" in indicators['trend']:
            strategies.append("üî¥ –¢—Ä–µ–Ω–¥ –Ω–∏—Å—Ö–æ–¥—è—â–∏–π - –∏–∑–±–µ–≥–∞–π—Ç–µ –ø–æ–∫—É–ø–æ–∫, —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–π—Ç–µ —à–æ—Ä—Ç—ã")
        
        # –°—Ç—Ä–∞—Ç–µ–≥–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∏—Å–∫–∞
        if risk_score > 70:
            strategies.append("‚ö° –í–´–°–û–ö–ò–ô –†–ò–°–ö - –∏–Ω–≤–µ—Å—Ç–∏—Ä—É–π—Ç–µ –Ω–µ –±–æ–ª–µ–µ 1-2% –∫–∞–ø–∏—Ç–∞–ª–∞")
        elif risk_score > 40:
            strategies.append("‚ö†Ô∏è –°–†–ï–î–ù–ò–ô –†–ò–°–ö - –∏–Ω–≤–µ—Å—Ç–∏—Ä—É–π—Ç–µ 3-5% –∫–∞–ø–∏—Ç–∞–ª–∞")
        else:
            strategies.append("üõ°Ô∏è –ù–ò–ó–ö–ò–ô –†–ò–°–ö - –º–æ–∂–Ω–æ –∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å 5-10% –∫–∞–ø–∏—Ç–∞–ª–∞")
        
        # –í—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä–∞–º–∫–∏
        if abs(price_change) > 10:
            strategies.append("‚è∞ –í—ã—Å–æ–∫–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å - —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–π—Ç–µ –∫—Ä–∞—Ç–∫–æ—Å—Ä–æ—á–Ω—ã–µ —Å–¥–µ–ª–∫–∏")
        else:
            strategies.append("üìÖ –ù–∏–∑–∫–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å - –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω—ã—Ö –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–π")
        
        return strategies
    
    def _generate_trading_signals(self, indicators, price_change):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤"""
        signals = []
        
        # –°–∏–≥–Ω–∞–ª—ã –ø–æ–∫—É–ø–∫–∏
        if indicators['rsi'] < 35 and "–í–û–°–•–û–î–Ø–©–ò–ô" in indicators['trend']:
            signals.append("üéØ –°–ò–ì–ù–ê–õ –ü–û–ö–£–ü–ö–ò: RSI –≤ –∑–æ–Ω–µ –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç–∏ + –≤–æ—Å—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–Ω–¥")
        
        if indicators['distance_to_support'] < 3:
            signals.append("üõ°Ô∏è –ë–õ–ò–ó–ö–û –ö –ü–û–î–î–ï–†–ñ–ö–ï: –•–æ—Ä–æ—à–∞—è —Ç–æ—á–∫–∞ –¥–ª—è –≤—Ö–æ–¥–∞ —Å–æ —Å—Ç–æ–ø-–ª–æ—Å—Å–æ–º")
        
        # –°–∏–≥–Ω–∞–ª—ã –ø—Ä–æ–¥–∞–∂–∏
        if indicators['rsi'] > 75:
            signals.append("üèÉ‚Äç‚ôÇÔ∏è –°–ò–ì–ù–ê–õ –ü–†–û–î–ê–ñ–ò: RSI –≤ –∑–æ–Ω–µ –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç–∏")
        
        if indicators['distance_to_resistance'] < 3:
            signals.append("‚õî –ë–õ–ò–ó–ö–û –ö –°–û–ü–†–û–¢–ò–í–õ–ï–ù–ò–Æ: –†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ —Ñ–∏–∫—Å–∞—Ü–∏—é –ø—Ä–∏–±—ã–ª–∏")
        
        # –°–∏–≥–Ω–∞–ª—ã –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ—Å—Ç–∏
        if indicators['volatility'] > 15:
            signals.append("üé¢ –í–´–°–û–ö–ê–Ø –í–û–õ–ê–¢–ò–õ–¨–ù–û–°–¢–¨: –£–º–µ–Ω—å—à–∏—Ç–µ —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏")
        
        if abs(price_change) > 20:
            signals.append("üö® –†–ï–ó–ö–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï –¶–ï–ù–´: –í–æ–∑–º–æ–∂–Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ü–∏—è")
        
        return signals
    
    def _generate_fallback_analysis(self, symbol):
        """–†–µ–∑–µ—Ä–≤–Ω—ã–π –∞–Ω–∞–ª–∏–∑"""
        base_prices = {
            'bitcoin': 45000, 'ethereum': 2500, 'binancecoin': 300,
            'ripple': 0.5, 'cardano': 0.4, 'solana': 100,
            'polkadot': 6, 'dogecoin': 0.1, 'avalanche-2': 30,
            'matic-network': 0.7
        }
        
        current_price = base_prices.get(symbol, random.uniform(0.1, 100))
        
        return {
            'symbol': symbol.upper(),
            'current_price': current_price,
            'price_change_24h': random.uniform(-10, 10),
            'price_change_7d': random.uniform(-20, 20),
            'market_cap': current_price * random.uniform(1e6, 1e9),
            'volume_24h': current_price * random.uniform(1e5, 1e8),
            'indicators': self._generate_fallback_indicators(),
            'risk_score': random.randint(20, 80),
            'strategy': ["–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ DCA —Å—Ç—Ä–∞—Ç–µ–≥–∏—é", "–î–∏–≤–µ—Ä—Å–∏—Ñ–∏—Ü–∏—Ä—É–π—Ç–µ –ø–æ—Ä—Ç—Ñ–µ–ª—å"],
            'signals': ["–î–∞–Ω–Ω—ã–µ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã"],
            'timestamp': datetime.now()
        }

    def get_market_overview(self):
        """–û–±–∑–æ—Ä —Ä—ã–Ω–∫–∞"""
        try:
            url = "https://api.coingecko.com/api/v3/global"
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                data = response.json()['data']
                return {
                    'total_market_cap': data['total_market_cap']['usd'],
                    'market_cap_change_24h': data['market_cap_change_percentage_24h_usd'],
                    'market_sentiment': "üü¢ –ë—ã—á–∏–π" if data['market_cap_change_percentage_24h_usd'] > 0 else "üî¥ –ú–µ–¥–≤–µ–∂–∏–π"
                }
        except:
            pass
        
        return {
            'total_market_cap': 2500000000000,
            'market_cap_change_24h': random.uniform(-5, 5),
            'market_sentiment': random.choice(["üü¢ –ë—ã—á–∏–π", "üî¥ –ú–µ–¥–≤–µ–∂–∏–π"])
        }

    def get_trending_coins(self):
        """–¢—Ä–µ–Ω–¥–æ–≤—ã–µ –º–æ–Ω–µ—Ç—ã"""
        try:
            url = "https://api.coingecko.com/api/v3/search/trending"
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                data = response.json()
                trending = []
                for coin in data['coins'][:5]:
                    trending.append({
                        'name': coin['item']['name'],
                        'symbol': coin['item']['symbol']
                    })
                return trending
        except:
            pass
        
        # –†–µ–∑–µ—Ä–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        return [
            {'name': 'Bitcoin', 'symbol': 'btc'},
            {'name': 'Ethereum', 'symbol': 'eth'},
            {'name': 'Solana', 'symbol': 'sol'},
            {'name': 'Cardano', 'symbol': 'ada'},
            {'name': 'Dogecoin', 'symbol': 'doge'}
        ]

# ==================== –£–õ–£–ß–®–ï–ù–ù–ê–Ø –ò–ì–†–ê LIGHT COIN ====================
class EnhancedLightCoinGame:
    def __init__(self):
        self.light_price = 0.01
        self.market_cap = 500000
        self.total_supply = 1000000000
        self.user_balances = {}
        self.user_levels = {}
        self.user_pages = {}
        self.user_eliminated = {}
        self.daily_writes = {}
        self.user_achievements = {}
        
    def get_user_data(self, user_id, username):
        if user_id not in self.user_balances:
            self.user_balances[user_id] = 0
            self.user_levels[user_id] = 1
            self.user_pages[user_id] = 1
            self.user_eliminated[user_id] = 0
        
        return {
            'user_id': user_id,
            'username': username,
            'light_balance': self.user_balances[user_id],
            'level': self.user_levels[user_id],
            'death_note_pages': self.user_pages[user_id],
            'eliminated_targets': self.user_eliminated[user_id],
            'shinigami_eyes': self.user_levels[user_id] >= 5,
            'achievements': self.user_achievements.get(user_id, [])
        }
    
    def add_write(self, user_id):
        """–£–ª—É—á—à–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∑–∞–ø–∏—Å–µ–π –≤ —Ç–µ—Ç—Ä–∞–¥–∏"""
        today = datetime.now().date()
        
        if user_id not in self.daily_writes:
            self.daily_writes[user_id] = {'date': today, 'count': 0}
        
        if self.daily_writes[user_id]['date'] != today:
            self.daily_writes[user_id] = {'date': today, 'count': 0}
        
        user_data = self.get_user_data(user_id, "")
        daily_limit = 20 + (user_data['death_note_pages'] * 5)
        
        if self.daily_writes[user_id]['count'] >= daily_limit:
            return False, f"‚ùå –î–æ—Å—Ç–∏–≥–Ω—É—Ç –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –∑–∞–ø–∏—Å–µ–π ({daily_limit})!"
        
        self.daily_writes[user_id]['count'] += 1
        
        # –ù–∞–≥—Ä–∞–¥–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —É—Ä–æ–≤–Ω—è –∏ —Å—Ç—Ä–∞–Ω–∏—Ü —Ç–µ—Ç—Ä–∞–¥–∏
        base_reward = random.uniform(1.0, 10.0)
        level_bonus = user_data['level'] * 0.5
        pages_bonus = user_data['death_note_pages'] * 0.3
        total_reward = base_reward + level_bonus + pages_bonus
        
        self.user_balances[user_id] += total_reward
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Ä–æ–≤–Ω—è
        if self.user_balances[user_id] >= self.user_levels[user_id] * 100:
            self.user_levels[user_id] += 1
            # –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
            if self.user_levels[user_id] >= 5:
                achievement_msg = "üëÅÔ∏è –ì–ª–∞–∑–∞ –®–∏–Ω–∏–≥–∞–º–∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã!"
            elif self.user_levels[user_id] % 3 == 0:
                self.user_pages[user_id] += 1
                achievement_msg = f"üìñ +1 —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Ç–µ—Ç—Ä–∞–¥–∏! –í—Å–µ–≥–æ: {self.user_pages[user_id]}"
            else:
                achievement_msg = f"üéâ –£—Ä–æ–≤–µ–Ω—å –ø–æ–≤—ã—à–µ–Ω –¥–æ {self.user_levels[user_id]}!"
            
            return True, f"‚úçÔ∏è –ó–∞–ø–∏—Å—å –≤ —Ç–µ—Ç—Ä–∞–¥—å! +{total_reward:.2f} LIGHT\n{achievement_msg}"
        
        return True, f"‚úçÔ∏è –ó–∞–ø–∏—Å—å –≤ —Ç–µ—Ç—Ä–∞–¥—å! +{total_reward:.2f} LIGHT"
    
    def eliminate_target(self, user_id, target_name, crime_level, difficulty):
        """–£–ª—É—á—à–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è —Ü–µ–ª–µ–π"""
        if crime_level < 1 or crime_level > 10:
            return False, "‚ùå –£—Ä–æ–≤–µ–Ω—å –ø—Ä–µ—Å—Ç—É–ø–ª–µ–Ω–∏—è –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 1 –¥–æ 10"
        
        user_data = self.get_user_data(user_id, "")
        
        # –ù–∞–≥—Ä–∞–¥–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –∏ —É—Ä–æ–≤–Ω—è –ø—Ä–µ—Å—Ç—É–ø–ª–µ–Ω–∏—è
        base_reward = crime_level * 20
        difficulty_multiplier = {'–ª–µ–≥–∫–∞—è': 1, '—Å—Ä–µ–¥–Ω—è—è': 1.5, '—Å–ª–æ–∂–Ω–∞—è': 2.5}
        reward = base_reward * difficulty_multiplier.get(difficulty, 1)
        
        # –ë–æ–Ω—É—Å –∑–∞ –≥–ª–∞–∑–∞ —à–∏–Ω–∏–≥–∞–º–∏
        if user_data['shinigami_eyes']:
            reward *= 1.5
        
        self.user_balances[user_id] += reward
        self.user_eliminated[user_id] += 1
        
        # –°–∏–ª—å–Ω–æ–µ –≤–ª–∏—è–Ω–∏–µ –Ω–∞ —Ä—ã–Ω–æ–∫
        self.light_price *= 1.05
        self.market_cap = self.light_price * self.total_supply
        
        return True, f"‚ò†Ô∏è –¶–µ–ª—å '{target_name}' —É—Å—Ç—Ä–∞–Ω–µ–Ω–∞! +{reward:.2f} LIGHT\nüìà –¶–µ–Ω–∞ LIGHT –≤—ã—Ä–æ—Å–ª–∞!"
    
    def get_market_data(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
        return {
            'price': self.light_price,
            'market_cap': self.market_cap,
            'total_supply': self.total_supply,
            'volatility': random.uniform(3, 12)
        }
    
    def get_leaderboard(self, limit=10):
        """–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤"""
        leaders = []
        for user_id, balance in self.user_balances.items():
            leaders.append({
                'username': f"–ò–≥—Ä–æ–∫_{user_id}",
                'balance': balance,
                'level': self.user_levels.get(user_id, 1),
                'eliminated': self.user_eliminated.get(user_id, 0),
                'pages': self.user_pages.get(user_id, 1)
            })
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –±–∞–ª–∞–Ω—Å—É –∏ –±–µ—Ä–µ–º —Ç–æ–ø-10
        leaders.sort(key=lambda x: x['balance'], reverse=True)
        return leaders[:10]

# ==================== –°–ò–°–¢–ï–ú–ê –û–¢–ó–´–í–û–í ====================
class ReviewSystem:
    def __init__(self):
        self.conn = sqlite3.connect('reviews.db', check_same_thread=False)
        self.create_table()
    
    def create_table(self):
        cursor = self.conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS reviews (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                username TEXT,
                rating INTEGER,
                comment TEXT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                is_approved BOOLEAN DEFAULT FALSE
            )
        ''')
        self.conn.commit()
    
    def add_review(self, user_id, username, rating, comment):
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                INSERT INTO reviews (user_id, username, rating, comment, is_approved)
                VALUES (?, ?, ?, ?, ?)
            ''', (user_id, username, rating, comment, True))
            self.conn.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –æ—Ç–∑—ã–≤–∞: {e}")
            return False
    
    def get_approved_reviews(self, limit=10):
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT username, rating, comment, timestamp 
                FROM reviews 
                WHERE is_approved = TRUE 
                ORDER BY timestamp DESC 
                LIMIT ?
            ''', (limit,))
            return cursor.fetchall()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–∑—ã–≤–æ–≤: {e}")
            return []
    
    def get_user_review(self, user_id):
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT rating, comment, timestamp 
                FROM reviews 
                WHERE user_id = ? 
                ORDER BY timestamp DESC 
                LIMIT 1
            ''', (user_id,))
            return cursor.fetchone()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–∑—ã–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            return None
    
    def get_reviews_stats(self):
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT 
                    COUNT(*) as total,
                    AVG(rating) as avg_rating,
                    COUNT(CASE WHEN rating = 5 THEN 1 END) as five_stars
                FROM reviews 
                WHERE is_approved = TRUE
            ''')
            return cursor.fetchone()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")
            return (0, 0, 0)

# ==================== –°–ò–°–¢–ï–ú–ê –°–ê–ú–û–û–ë–£–ß–ï–ù–ò–Ø ====================
class SelfLearningSystem:
    def __init__(self):
        self.performance_db = sqlite3.connect('bot_learning.db', check_same_thread=False)
        self.create_learning_tables()
        self.optimization_history = []
    
    def create_learning_tables(self):
        cursor = self.performance_db.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS command_metrics (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                command TEXT,
                user_id INTEGER,
                response_time REAL,
                success BOOLEAN,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        self.performance_db.commit()
    
    def log_command_usage(self, command, user_id, response_time, success):
        try:
            cursor = self.performance_db.cursor()
            cursor.execute('''
                INSERT INTO command_metrics (command, user_id, response_time, success)
                VALUES (?, ?, ?, ?)
            ''', (command, user_id, response_time, success))
            self.performance_db.commit()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã: {e}")
    
    def analyze_performance(self):
        try:
            cursor = self.performance_db.cursor()
            cursor.execute('''
                SELECT command, 
                       AVG(response_time) as avg_time,
                       COUNT(*) as usage_count,
                       SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as success_count
                FROM command_metrics 
                WHERE timestamp > datetime('now', '-7 days')
                GROUP BY command
            ''')
            return cursor.fetchall()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏: {e}")
            return []

# ==================== –°–¢–ò–õ–ò–ó–û–í–ê–ù–ù–´–ô –ë–û–¢ ====================
class DeathNoteStyledBot:
    @staticmethod
    def format_message(title, content, message_type="info"):
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —Å—Ç–∏–ª–µ –¢–µ—Ç—Ä–∞–¥–∏ —Å–º–µ—Ä—Ç–∏"""
        styles = {
            "info": "üìñ",
            "warning": "‚ö°", 
            "success": "üîÆ",
            "danger": "‚ò†Ô∏è",
            "analysis": "üéØ",
            "review": "‚≠ê"
        }
        
        emoji = styles.get(message_type, "üìñ")
        
        return f"""
{emoji} <b>„Ää{title}„Äã</b>
{content}
        """
    
    @staticmethod
    def create_death_note_keyboard(buttons, back_button=True):
        """–°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –≤ —Å—Ç–∏–ª–µ –¢–µ—Ç—Ä–∞–¥–∏ —Å–º–µ—Ä—Ç–∏"""
        keyboard = []
        
        # –î–æ–±–∞–≤–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏
        for i in range(0, len(buttons), 2):
            row = buttons[i:i+2]
            keyboard.append(row)
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –Ω–∞–∑–∞–¥
        if back_button:
            keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è –í –¢–ï–ù–¨", callback_data="back_main")])
        
        return InlineKeyboardMarkup(keyboard)

# ==================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –°–ò–°–¢–ï–ú ====================
nft_system = ExclusiveNFTSystem()
analyzer = AdvancedMarketAnalyzer()
light_game = EnhancedLightCoinGame()
review_system = ReviewSystem()
learning_system = SelfLearningSystem()
styled_bot = DeathNoteStyledBot()

# ==================== –ì–õ–ê–í–ù–´–ï –ö–û–ú–ê–ù–î–´ ====================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ì–ª–∞–≤–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –≤ —Å—Ç–∏–ª–µ –¢–µ—Ç—Ä–∞–¥–∏ —Å–º–µ—Ä—Ç–∏"""
    user = update.effective_user
    
    # –õ–æ–≥–∏—Ä—É–µ–º —Å—Ç–∞—Ä—Ç–æ–≤–æ–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ
    learning_system.log_command_usage('start', user.id, 0.1, True)
    
    welcome_text = styled_bot.format_message(
        "–¢–ï–¢–†–ê–î–¨ –°–ú–ï–†–¢–ò - CRYPTO ANALYTICS",
        f"""
üëÅÔ∏è <b>–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é, {user.first_name}!</b>

–Ø - <b>Kira</b>, —Ç–≤–æ–π –ø—Ä–æ–≤–æ–¥–Ω–∏–∫ –≤ –º–∏—Ä–µ –∫—Ä–∏–ø—Ç–æ-–∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –∏ –±–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–π —Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ—Å—Ç–∏.

<b>üìä –†–ï–ê–õ–¨–ù–´–ô –ê–ù–ê–õ–ò–ó:</b>
‚Ä¢ –ì–ª—É–±–æ–∫–∏–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑
‚Ä¢ –ò–Ω–≤–µ—Å—Ç–∏—Ü–∏–æ–Ω–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ 
‚Ä¢ –°–∏–≥–Ω–∞–ª—ã –ø–æ–∫—É–ø–∫–∏/–ø—Ä–æ–¥–∞–∂–∏
‚Ä¢ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∏—Å–∫–∞–º–∏

<b>üîÆ LIGHT COIN –ò–ì–†–ê:</b>
‚Ä¢ –°—Ç–∞–Ω—å –ë–æ–≥–æ–º –Ω–æ–≤–æ–≥–æ –º–∏—Ä–∞
‚Ä¢ –í–µ—Ä—à–∏ –ø—Ä–∞–≤–æ—Å—É–¥–∏–µ
‚Ä¢ –ó–∞—Ä–∞–±–∞—Ç—ã–≤–∞–π LIGHT –º–æ–Ω–µ—Ç—ã
‚Ä¢ –°–æ—Ä–µ–≤–Ω—É–π—Å—è —Å –¥—Ä—É–≥–∏–º–∏

<b>üé¥ NFT –°–ò–°–¢–ï–ú–ê:</b>
‚Ä¢ –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏
‚Ä¢ –ü–æ–∫—É–ø–∫–∞ –∑–∞ Telegram Stars
‚Ä¢ –£–Ω–∏–∫–∞–ª—å–Ω—ã–µ –±–æ–Ω—É—Å—ã

<b>‚≠ê –°–ò–°–¢–ï–ú–ê –û–¢–ó–´–í–û–í:</b>
‚Ä¢ –û—Ü–µ–Ω–∏—Ç–µ —Ä–∞–±–æ—Ç—É –±–æ—Ç–∞
‚Ä¢ –ß–∏—Ç–∞–π—Ç–µ –æ—Ç–∑—ã–≤—ã –¥—Ä—É–≥–∏—Ö
‚Ä¢ –ü–æ–º–æ–≥–∏—Ç–µ –Ω–∞–º —Å—Ç–∞—Ç—å –ª—É—á—à–µ

<b>ü§ñ –°–ê–ú–û–û–ë–£–ß–ï–ù–ò–ï:</b>
‚Ä¢ –ë–æ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–ª—É—á—à–∞–µ—Ç—Å—è
‚Ä¢ –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
‚Ä¢ –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

<b>‚ö° –ö–û–ú–ê–ù–î–´:</b>
/analysis - –ê–Ω–∞–ª–∏–∑ —Ä—ã–Ω–∫–∞
/game - –ò–≥—Ä–∞ Light Coin  
/nft - NFT –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å
/reviews - –°–∏—Å—Ç–µ–º–∞ –æ—Ç–∑—ã–≤–æ–≤
/help - –í—Å–µ –∫–æ–º–∞–Ω–¥—ã

<b>–í—ã–±–µ—Ä–∏ —Å–≤–æ–π –ø—É—Ç—å:</b>
        """
    )
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("üìä –ê–ù–ê–õ–ò–ó –†–´–ù–ö–ê", callback_data="analysis_menu"),
        InlineKeyboardButton("üîÆ –ò–ì–†–ê LIGHT COIN", callback_data="game_menu"),
        InlineKeyboardButton("üé¥ NFT –ú–ê–†–ö–ï–¢–ü–õ–ï–ô–°", callback_data="nft_market"),
        InlineKeyboardButton("‚≠ê –û–¢–ó–´–í–´", callback_data="reviews_menu"),
        InlineKeyboardButton("‚ö° –ü–û–ú–û–©–¨", callback_data="help")
    ], back_button=False)
    
    await update.message.reply_text(welcome_text, parse_mode='HTML', reply_markup=keyboard)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ –ø–æ–º–æ—â–∏"""
    help_text = styled_bot.format_message(
        "–ü–û–ú–û–©–¨ - –í–°–ï –ö–û–ú–ê–ù–î–´",
        """
<b>üîÆ –û–°–ù–û–í–ù–´–ï –ö–û–ú–ê–ù–î–´:</b>
/start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
/help - –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞

<b>üìä –ê–ù–ê–õ–ò–ó –†–´–ù–ö–ê:</b>
/analysis - –ú–µ–Ω—é –∞–Ω–∞–ª–∏–∑–∞
/bitcoin - –ê–Ω–∞–ª–∏–∑ Bitcoin
/ethereum - –ê–Ω–∞–ª–∏–∑ Ethereum  
/solana - –ê–Ω–∞–ª–∏–∑ Solana
/market - –û–±–∑–æ—Ä —Ä—ã–Ω–∫–∞
/trending - –¢—Ä–µ–Ω–¥–æ–≤—ã–µ –º–æ–Ω–µ—Ç—ã

<b>üéÆ –ò–ì–†–ê LIGHT COIN:</b>
/game - –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
/mystats - –ú–æ–π —Å—Ç–∞—Ç—É—Å
/write - –°–¥–µ–ª–∞—Ç—å –∑–∞–ø–∏—Å—å
/targets - –£—Å—Ç—Ä–∞–Ω–∏—Ç—å —Ü–µ–ª—å
/leaderboard - –†–µ–π—Ç–∏–Ω–≥ –∏–≥—Ä–æ–∫–æ–≤
/lightmarket - –†—ã–Ω–æ–∫ LIGHT

<b>üé¥ NFT –°–ò–°–¢–ï–ú–ê:</b>
/nft - NFT –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å
/mystars - –ú–æ–∏ –∑–≤–µ–∑–¥—ã
/mynfts - –ú–æ–∏ NFT

<b>‚≠ê –°–ò–°–¢–ï–ú–ê –û–¢–ó–´–í–û–í:</b>
/reviews - –û—Ç–∑—ã–≤—ã –∏ —Ä–µ–π—Ç–∏–Ω–≥–∏

<b>‚ö° –°–û–í–ï–¢:</b>
–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –¥–ª—è —É–¥–æ–±–Ω–æ–π –Ω–∞–≤–∏–≥–∞—Ü–∏–∏!
        """
    )
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("üìä –ê–ù–ê–õ–ò–ó", callback_data="analysis_menu"),
        InlineKeyboardButton("üîÆ –ò–ì–†–ê", callback_data="game_menu"),
        InlineKeyboardButton("üé¥ NFT", callback_data="nft_market"),
        InlineKeyboardButton("‚≠ê –û–¢–ó–´–í–´", callback_data="reviews_menu"),
        InlineKeyboardButton("‚¨ÖÔ∏è –ì–õ–ê–í–ù–ê–Ø", callback_data="back_main")
    ])
    
    await update.message.reply_text(help_text, parse_mode='HTML', reply_markup=keyboard)

# ==================== NFT –ö–û–ú–ê–ù–î–´ ====================
async def nft_marketplace_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """NFT –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å"""
    query = update.callback_query
    if query:
        await query.answer()
    
    marketplace_text = nft_system.get_nft_marketplace()
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("‚≠ê –ú–û–ò –ó–í–ï–ó–î–´", callback_data="my_stars"),
        InlineKeyboardButton("üé¥ –ú–û–ò NFT", callback_data="my_nfts"),
        InlineKeyboardButton("üìû –°–í–Ø–ó–ê–¢–¨–°–Ø", url="https://t.me/beyondbesdey"),
        InlineKeyboardButton("‚¨ÖÔ∏è –ù–ê–ó–ê–î", callback_data="back_main")
    ])
    
    if query:
        await query.edit_message_text(marketplace_text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(marketplace_text, parse_mode='HTML', reply_markup=keyboard)

async def my_stars_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ú–æ–∏ –∑–≤–µ–∑–¥—ã"""
    query = update.callback_query
    if query:
        await query.answer()
    
    user_id = update.effective_user.id
    stars_balance = nft_system.get_user_stars(user_id)
    
    text = f"""
‚≠ê <b>–í–ê–® –ë–ê–õ–ê–ù–° –ó–í–ï–ó–î</b>

üí∞ <b>–ó–≤–µ–∑–¥:</b> {stars_balance}

üîÆ <b>–ö–∞–∫ –ø–æ–ª—É—á–∏—Ç—å –∑–≤–µ–∑–¥—ã:</b>
1. –ù–∞–ø–∏—à–∏—Ç–µ @beyondbesdey
2. –û—Ç–ø—Ä–∞–≤—å—Ç–µ Stars —á–µ—Ä–µ–∑ Telegram
3. –ó–≤–µ–∑–¥—ã –∑–∞—á–∏—Å–ª—è—Ç—Å—è –Ω–∞ –≤–∞—à –±–∞–ª–∞–Ω—Å!

üíé –ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –≤—ã —Å–º–æ–∂–µ—Ç–µ –ø–æ–∫—É–ø–∞—Ç—å NFT!
    """
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("üõí NFT –ú–ê–†–ö–ï–¢", callback_data="nft_market"),
        InlineKeyboardButton("üìû –û–¢–ü–†–ê–í–ò–¢–¨ –ó–í–ï–ó–î–´", url="https://t.me/beyondbesdey"),
        InlineKeyboardButton("‚¨ÖÔ∏è –ù–ê–ó–ê–î", callback_data="back_main")
    ])
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

async def my_nfts_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ú–æ–∏ NFT"""
    query = update.callback_query
    if query:
        await query.answer()
    
    user_id = update.effective_user.id
    user_nfts = nft_system.get_user_nfts(user_id)
    
    if not user_nfts:
        text = "üé¥ <b>–£ –í–ê–° –ü–û–ö–ê –ù–ï–¢ NFT</b>\n\n–ü–æ—Å–µ—Ç–∏—Ç–µ –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å —á—Ç–æ–±—ã –ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –ø—Ä–µ–¥–º–µ—Ç—ã!"
    else:
        text = "üé¥ <b>–í–ê–®–ê –ö–û–õ–õ–ï–ö–¶–ò–Ø NFT</b>\n\n"
        for nft in user_nfts:
            text += f"{nft['image']} <b>{nft['name']}</b>\n"
            text += f"   üéØ {nft['rarity']}\n"
            for benefit in nft['benefits']:
                text += f"   üí° {benefit}\n"
            text += "\n"
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("üõí –ú–ê–†–ö–ï–¢–ü–õ–ï–ô–°", callback_data="nft_market"),
        InlineKeyboardButton("‚≠ê –ú–û–ò –ó–í–ï–ó–î–´", callback_data="my_stars"),
        InlineKeyboardButton("‚¨ÖÔ∏è –ù–ê–ó–ê–î", callback_data="back_main")
    ])
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

# ==================== –£–õ–£–ß–®–ï–ù–ù–´–ô –ê–ù–ê–õ–ò–ó ====================
async def analysis_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ú–µ–Ω—é –∞–Ω–∞–ª–∏–∑–∞"""
    query = update.callback_query
    if query:
        await query.answer()
    
    text = styled_bot.format_message(
        "–ê–ù–ê–õ–ò–ó –†–´–ù–ö–ê - –í–´–ë–ï–†–ò –ú–û–ù–ï–¢–£",
        """
<b>üéØ –î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–Ω–µ—Ç—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞:</b>

‚Ä¢ Bitcoin (BTC) - —Ü–∏—Ñ—Ä–æ–≤–æ–µ –∑–æ–ª–æ—Ç–æ
‚Ä¢ Ethereum (ETH) - —Å–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç—ã  
‚Ä¢ Solana (SOL) - –≤—ã—Å–æ–∫–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
‚Ä¢ Cardano (ADA) - –Ω–∞—É—á–Ω—ã–π –ø–æ–¥—Ö–æ–¥
‚Ä¢ Polkadot (DOT) - –∏–Ω—Ç–µ—Ä–æ–ø–µ—Ä–∞–±–µ–ª—å–Ω–æ—Å—Ç—å

<b>‚ö° –ß—Ç–æ —Ç—ã –ø–æ–ª—É—á–∏—à—å:</b>
‚Ä¢ –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
‚Ä¢ –£—Ä–æ–≤–Ω–∏ —Ä–∏—Å–∫–∞
‚Ä¢ –°—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
‚Ä¢ –¢–æ—Ä–≥–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã
        """
    )
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("‚Çø BITCOIN", callback_data="analyze_bitcoin"),
        InlineKeyboardButton("Œû ETHEREUM", callback_data="analyze_ethereum"),
        InlineKeyboardButton("üî∏ SOLANA", callback_data="analyze_solana"),
        InlineKeyboardButton("üêï DOGECOIN", callback_data="analyze_dogecoin"),
        InlineKeyboardButton("üìà –û–ë–ó–û–† –†–´–ù–ö–ê", callback_data="market_overview"),
        InlineKeyboardButton("üöÄ –¢–†–ï–ù–î–´", callback_data="trending"),
        InlineKeyboardButton("üîÆ –í –ò–ì–†–£", callback_data="game_menu"),
        InlineKeyboardButton("üé¥ NFT", callback_data="nft_market")
    ])
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

async def comprehensive_analysis(update: Update, context: ContextTypes.DEFAULT_TYPE, symbol=None):
    """–ö–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–æ–Ω–Ω—ã–º–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è–º–∏"""
    if not symbol:
        query = update.callback_query
        symbol = query.data.replace('analyze_', '')
        await query.answer()
    
    analysis = analyzer.generate_comprehensive_analysis(symbol)
    
    if not analysis:
        text = styled_bot.format_message("–û–®–ò–ë–ö–ê", "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ", "danger")
        if hasattr(update, 'callback_query'):
            await update.callback_query.edit_message_text(text, parse_mode='HTML')
        else:
            await update.message.reply_text(text, parse_mode='HTML')
        return
    
    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –∞–Ω–∞–ª–∏–∑
    analysis_text = f"""
<b>üíé {analysis['symbol']}</b>
üí∞ –¶–µ–Ω–∞: ${analysis['current_price']:,.2f}
üìà 24—á: {analysis['price_change_24h']:+.2f}%
üìä 7–¥: {analysis['price_change_7d']:+.2f}%

<b>üìä –¢–ï–•–ù–ò–ß–ï–°–ö–ò–ï –ò–ù–î–ò–ö–ê–¢–û–†–´:</b>
‚Ä¢ RSI: {analysis['indicators']['rsi']}
‚Ä¢ –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å: {analysis['indicators']['volatility']}%
‚Ä¢ –¢—Ä–µ–Ω–¥: {analysis['indicators']['trend']}
‚Ä¢ –ö —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—é: +{analysis['indicators']['distance_to_resistance']}%
‚Ä¢ –ö –ø–æ–¥–¥–µ—Ä–∂–∫–µ: -{analysis['indicators']['distance_to_support']}%

<b>‚ö° –û–¶–ï–ù–ö–ê –†–ò–°–ö–ê:</b> {analysis['risk_score']}/100

<b>üéØ –°–¢–†–ê–¢–ï–ì–ò–Ø:</b>
"""
    
    for strategy in analysis['strategy'][:3]:
        analysis_text += f"‚Ä¢ {strategy}\n"
    
    analysis_text += f"\n<b>üì¢ –°–ò–ì–ù–ê–õ–´:</b>"
    for signal in analysis['signals'][:2]:
        analysis_text += f"\n‚Ä¢ {signal}"
    
    analysis_text += f"\n\n‚è∞ {analysis['timestamp'].strftime('%d.%m.%Y %H:%M')}"
    
    text = styled_bot.format_message(f"–ê–ù–ê–õ–ò–ó {analysis['symbol']}", analysis_text, "analysis")
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("üîÑ –û–ë–ù–û–í–ò–¢–¨", callback_data=f"analyze_{symbol}"),
        InlineKeyboardButton("üìä –î–†–£–ì–ê–Ø –ú–û–ù–ï–¢–ê", callback_data="analysis_menu"),
        InlineKeyboardButton("üîÆ –í –ò–ì–†–£", callback_data="game_menu"),
        InlineKeyboardButton("üé¥ NFT", callback_data="nft_market")
    ])
    
    if hasattr(update, 'callback_query'):
        await update.callback_query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

async def market_overview(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±–∑–æ—Ä —Ä—ã–Ω–∫–∞"""
    query = update.callback_query
    if query:
        await query.answer()
    
    overview = analyzer.get_market_overview()
    
    if overview:
        text = f"""
üåê <b>–û–ë–ó–û–† –†–´–ù–ö–ê</b>

üíé –ö–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è: ${overview['total_market_cap']/1e12:.2f} —Ç—Ä–ª–Ω
üìà –ò–∑–º–µ–Ω–µ–Ω–∏–µ: {overview['market_cap_change_24h']:+.2f}%
üé≠ –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ: {overview['market_sentiment']}

üöÄ –¢—Ä–µ–Ω–¥–æ–≤—ã–µ –º–æ–Ω–µ—Ç—ã:
"""
        for i, coin in enumerate(overview['trending_coins'][:3], 1):
            text += f"{i}. {coin['name']} ({coin['symbol']})\n"
    else:
        text = "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Ä—ã–Ω–∫–∞"
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("üìä –ê–ù–ê–õ–ò–ó", callback_data="analysis_menu"),
        InlineKeyboardButton("üîÆ –ò–ì–†–ê", callback_data="game_menu"),
        InlineKeyboardButton("üé¥ NFT", callback_data="nft_market")
    ])
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

async def trending_coins(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–¢—Ä–µ–Ω–¥–æ–≤—ã–µ –º–æ–Ω–µ—Ç—ã"""
    query = update.callback_query
    if query:
        await query.answer()
    
    trending = analyzer.get_trending_coins()
    
    text = "üî• <b>–¢–†–ï–ù–î–û–í–´–ï –ú–û–ù–ï–¢–´</b>\n\n"
    for i, coin in enumerate(trending[:5], 1):
        text += f"{i}. {coin['name']} ({coin['symbol'].upper()})\n"
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("üìä –ê–ù–ê–õ–ò–ó", callback_data="analysis_menu"),
        InlineKeyboardButton("üîÆ –ò–ì–†–ê", callback_data="game_menu"),
        InlineKeyboardButton("üé¥ NFT", callback_data="nft_market")
    ])
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

# ==================== –£–õ–£–ß–®–ï–ù–ù–ê–Ø –ò–ì–†–ê ====================
async def enhanced_light_coin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–£–ª—É—á—à–µ–Ω–Ω–æ–µ –º–µ–Ω—é –∏–≥—Ä—ã"""
    query = update.callback_query
    if query:
        await query.answer()
    
    user_id = update.effective_user.id
    username = update.effective_user.first_name
    user_data = light_game.get_user_data(user_id, username)
    
    game_text = f"""
<b>üë§ –í–õ–ê–î–ï–õ–ï–¶:</b> {username}
<b>üíé –£–†–û–í–ï–ù–¨:</b> {user_data['level']}
<b>üí∞ –ë–ê–õ–ê–ù–°:</b> {user_data['light_balance']:.2f} LIGHT
<b>üìñ –°–¢–†–ê–ù–ò–¶:</b> {user_data['death_note_pages']}
<b>‚ò†Ô∏è –¶–ï–õ–ï–ô:</b> {user_data['eliminated_targets']}

<b>{'üëÅÔ∏è –ì–õ–ê–ó–ê –®–ò–ù–ò–ì–ê–ú–ò: –ê–ö–¢–ò–í–ù–´' if user_data['shinigami_eyes'] else 'üîí –ì–õ–ê–ó–ê –®–ò–ù–ò–ì–ê–ú–ò: –ó–ê–ë–õ–û–ö–ò–†–û–í–ê–ù–´'}</b>

<b>üéØ –î–û–°–¢–ò–ñ–ï–ù–ò–Ø:</b> {len(user_data['achievements'])}/10
"""
    
    text = styled_bot.format_message("LIGHT COIN - –¢–ï–¢–†–ê–î–¨ –°–ú–ï–†–¢–ò", game_text, "success")
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("‚úçÔ∏è –°–î–ï–õ–ê–¢–¨ –ó–ê–ü–ò–°–¨", callback_data="light_write"),
        InlineKeyboardButton("‚ò†Ô∏è –£–°–¢–†–ê–ù–ò–¢–¨ –¶–ï–õ–¨", callback_data="light_eliminate"),
        InlineKeyboardButton("üìä –ú–û–ô –°–¢–ê–¢–£–°", callback_data="light_status"),
        InlineKeyboardButton("üèÜ –¢–ê–ë–õ–ò–¶–ê –õ–ò–î–ï–†–û–í", callback_data="light_leaderboard"),
        InlineKeyboardButton("üíé –†–´–ù–û–ö LIGHT", callback_data="light_market"),
        InlineKeyboardButton("üìä –ê–ù–ê–õ–ò–ó –†–´–ù–ö–ê", callback_data="analysis_menu"),
        InlineKeyboardButton("üé¥ NFT", callback_data="nft_market")
    ])
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

async def light_write_action(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ó–∞–ø–∏—Å—å –≤ —Ç–µ—Ç—Ä–∞–¥—å"""
    query = update.callback_query
    if query:
        await query.answer()
    
    user_id = update.effective_user.id
    success, message = light_game.add_write(user_id)
    
    events = [
        "–ó–∞–ø–∏—Å—å –æ –±—É–¥—É—â–∏—Ö —Å–æ–±—ã—Ç–∏—è—Ö",
        "–ò–º–µ–Ω–∞ –∫–æ—Ä—Ä—É–º–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª–∏—Ç–∏–∫–æ–≤", 
        "–ü–ª–∞–Ω –ø–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—é —Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ—Å—Ç–∏"
    ]
    event = random.choice(events)
    
    if success:
        text = f"‚úçÔ∏è <b>–ó–ê–ü–ò–°–¨ –í –¢–ï–¢–†–ê–î–ò</b>\n\nüìñ {event}\n\n{message}"
    else:
        text = message
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("‚úçÔ∏è –ï–©–ï –ó–ê–ü–ò–°–¨", callback_data="light_write"),
        InlineKeyboardButton("üìä –°–¢–ê–¢–£–°", callback_data="light_status"),
        InlineKeyboardButton("üîÆ –í –ò–ì–†–£", callback_data="game_menu")
    ])
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

async def light_eliminate_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ú–µ–Ω—é —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è —Ü–µ–ª–µ–π"""
    query = update.callback_query
    if query:
        await query.answer()
    
    targets = [
        {"name": "–ö–æ—Ä—Ä—É–º–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–ª–∏—Ç–∏–∫", "level": random.randint(3, 8), "difficulty": "—Å—Ä–µ–¥–Ω—è—è"},
        {"name": "–ù–∞—Ä–∫–æ–±–∞—Ä–æ–Ω", "level": random.randint(6, 10), "difficulty": "—Å–ª–æ–∂–Ω–∞—è"},
        {"name": "–ú–æ—à–µ–Ω–Ω–∏–∫", "level": random.randint(2, 5), "difficulty": "–ª–µ–≥–∫–∞—è"}
    ]
    
    keyboard = []
    for target in targets:
        keyboard.append([
            InlineKeyboardButton(
                f"‚ò†Ô∏è {target['name']} (–£—Ä. {target['level']})", 
                callback_data=f"eliminate_{target['name']}_{target['level']}_{target['difficulty']}"
            )
        ])
    
    keyboard.append([
        InlineKeyboardButton("üîÆ –í –ò–ì–†–£", callback_data="game_menu")
    ])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    text = "‚ò†Ô∏è <b>–í–´–ë–ï–†–ò –¶–ï–õ–¨ –î–õ–Ø –£–°–¢–†–ê–ù–ï–ù–ò–Ø</b>\n\n–ß–µ–º –≤—ã—à–µ —É—Ä–æ–≤–µ–Ω—å - —Ç–µ–º –±–æ–ª—å—à–µ –Ω–∞–≥—Ä–∞–¥–∞!"
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=reply_markup)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=reply_markup)

async def light_eliminate_action(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ —Ü–µ–ª–∏"""
    query = update.callback_query
    await query.answer()
    
    user_id = update.effective_user.id
    data = query.data.replace('eliminate_', '').split('_')
    target_name = data[0]
    crime_level = int(data[1])
    difficulty = data[2]
    
    success, message = light_game.eliminate_target(user_id, target_name, crime_level, difficulty)
    
    if success:
        text = f"‚ò†Ô∏è <b>–¶–ï–õ–¨ –£–°–¢–†–ê–ù–ï–ù–ê</b>\n\nüéØ {target_name}\n‚ö° –£—Ä–æ–≤–µ–Ω—å: {crime_level}\nüé™ –°–ª–æ–∂–Ω–æ—Å—Ç—å: {difficulty}\n\n{message}"
    else:
        text = message
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("‚ò†Ô∏è –ù–û–í–ê–Ø –¶–ï–õ–¨", callback_data="light_eliminate"),
        InlineKeyboardButton("üìä –°–¢–ê–¢–£–°", callback_data="light_status"),
        InlineKeyboardButton("üîÆ –í –ò–ì–†–£", callback_data="game_menu")
    ])
    
    await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)

async def light_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–°—Ç–∞—Ç—É—Å –∏–≥—Ä–æ–∫–∞"""
    query = update.callback_query
    if query:
        await query.answer()
    
    user_id = update.effective_user.id
    username = update.effective_user.first_name
    user_data = light_game.get_user_data(user_id, username)
    market_data = light_game.get_market_data()
    
    text = f"""
üîÆ <b>–°–¢–ê–¢–£–° –ò–ì–†–û–ö–ê</b>

üë§ –ò–≥—Ä–æ–∫: {username}
üíé –£—Ä–æ–≤–µ–Ω—å: {user_data['level']}
üí∞ –ë–∞–ª–∞–Ω—Å: {user_data['light_balance']:.2f} LIGHT
üìñ –°—Ç—Ä–∞–Ω–∏—Ü —Ç–µ—Ç—Ä–∞–¥–∏: {user_data['death_note_pages']}
‚ò†Ô∏è –£—Å—Ç—Ä–∞–Ω–µ–Ω–æ —Ü–µ–ª–µ–π: {user_data['eliminated_targets']}

{'üëÅÔ∏è –ì–ª–∞–∑–∞ –®–∏–Ω–∏–≥–∞–º–∏: –ê–ö–¢–ò–í–ù–´' if user_data['shinigami_eyes'] else 'üîí –ì–ª–∞–∑–∞ –®–∏–Ω–∏–≥–∞–º–∏: –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã (—É—Ä–æ–≤–µ–Ω—å 5+)'}

üíπ –†—ã–Ω–æ–∫ LIGHT:
‚Ä¢ –¶–µ–Ω–∞: ${market_data['price']:.6f}
‚Ä¢ –ö–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è: ${market_data['market_cap']:,.2f}

üéØ –ü—Ä–æ–¥–æ–ª–∂–∞–π –≤–µ—Ä—à–∏—Ç—å –ø—Ä–∞–≤–æ—Å—É–¥–∏–µ!
    """
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("‚úçÔ∏è –°–î–ï–õ–ê–¢–¨ –ó–ê–ü–ò–°–¨", callback_data="light_write"),
        InlineKeyboardButton("‚ò†Ô∏è –£–°–¢–†–ê–ù–ò–¢–¨ –¶–ï–õ–¨", callback_data="light_eliminate"),
        InlineKeyboardButton("üîÆ –í –ò–ì–†–£", callback_data="game_menu")
    ])
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

async def light_leaderboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤"""
    query = update.callback_query
    if query:
        await query.answer()
    
    leaders = light_game.get_leaderboard(10)
    
    text = "üèÜ <b>–¢–ê–ë–õ–ò–¶–ê –õ–ò–î–ï–†–û–í LIGHT COIN</b>\n\n"
    for i, leader in enumerate(leaders, 1):
        medal = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else f"{i}."
        text += f"{medal} {leader['username']}\n"
        text += f"   üí∞ {leader['balance']:.2f} LIGHT | ‚≠ê –£—Ä. {leader['level']} | ‚ò†Ô∏è {leader['eliminated']} —Ü–µ–ª–µ–π\n\n"
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("üîÆ –í –ò–ì–†–£", callback_data="game_menu")
    ])
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

async def light_market(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–†—ã–Ω–æ–∫ Light Coin"""
    query = update.callback_query
    if query:
        await query.answer()
    
    market_data = light_game.get_market_data()
    
    text = f"""
üíé <b>–†–´–ù–û–ö LIGHT COIN</b>

üí∞ –¶–µ–Ω–∞: ${market_data['price']:.6f}
üè¶ –ö–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è: ${market_data['market_cap']:,.2f}
üìä –û–±—â–µ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ: {market_data['total_supply']:,.0f} LIGHT
üé¢ –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å: {market_data['volatility']:.1f}%

üöÄ <b>–§–∞–∫—Ç–æ—Ä—ã —Ä–æ—Å—Ç–∞:</b>
‚Ä¢ –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –æ–ø–∞—Å–Ω—ã—Ö —Ü–µ–ª–µ–π
‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–ø–∏—Å–∏ –≤ —Ç–µ—Ç—Ä–∞–¥–∏
‚Ä¢ –†–æ—Å—Ç —Å–æ–æ–±—â–µ—Å—Ç–≤–∞

üí° –¶–µ–Ω–∞ —Ä–∞—Å—Ç–µ—Ç —Å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å—é –∏–≥—Ä–æ–∫–æ–≤!
    """
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("‚úçÔ∏è –°–î–ï–õ–ê–¢–¨ –ó–ê–ü–ò–°–¨", callback_data="light_write"),
        InlineKeyboardButton("üîÆ –í –ò–ì–†–£", callback_data="game_menu")
    ])
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

# ==================== –°–ò–°–¢–ï–ú–ê –û–¢–ó–´–í–û–í - –ö–û–ú–ê–ù–î–´ ====================
async def reviews_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ú–µ–Ω—é –æ—Ç–∑—ã–≤–æ–≤"""
    query = update.callback_query
    if query:
        await query.answer()
    
    stats = review_system.get_reviews_stats()
    total_reviews, avg_rating, five_stars = stats
    
    text = styled_bot.format_message(
        "–û–¢–ó–´–í–´ –ò –†–ï–ô–¢–ò–ù–ì–ò",
        f"""
‚≠ê <b>–û–ë–©–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê:</b>
üìä –í—Å–µ–≥–æ –æ—Ç–∑—ã–≤–æ–≤: {total_reviews}
üèÜ –°—Ä–µ–¥–Ω–∏–π —Ä–µ–π—Ç–∏–Ω–≥: {avg_rating:.1f}/5
üí´ 5-–∑–≤–µ–∑–¥–æ—á–Ω—ã—Ö: {five_stars}

üéØ <b>–í–∞—à –æ—Ç–∑—ã–≤ –ø–æ–º–æ–≥–∞–µ—Ç —Å—Ç–∞—Ç—å –ª—É—á—à–µ!</b>

–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:
        """,
        "review"
    )
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("‚≠ê –û–°–¢–ê–í–ò–¢–¨ –û–¢–ó–´–í", callback_data="leave_review"),
        InlineKeyboardButton("üìä –ü–û–°–ú–û–¢–†–ï–¢–¨ –û–¢–ó–´–í–´", callback_data="view_reviews"),
        InlineKeyboardButton("‚úçÔ∏è –ú–û–ô –û–¢–ó–´–í", callback_data="my_review"),
        InlineKeyboardButton("‚¨ÖÔ∏è –ì–õ–ê–í–ù–ê–Ø", callback_data="back_main")
    ])
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

async def leave_review_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ù–∞—á–∞–ª–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ –æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –æ—Ç–∑—ã–≤–∞"""
    query = update.callback_query
    if query:
        await query.answer()
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ - –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞—á–∞–ª –æ—Å—Ç–∞–≤–ª—è—Ç—å –æ—Ç–∑—ã–≤
    context.user_data['leaving_review'] = True
    
    text = styled_bot.format_message(
        "–ù–ê–ü–ò–°–ê–ù–ò–ï –û–¢–ó–´–í–ê",
        """
üìù <b>–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ü–µ–Ω–∏—Ç–µ –±–æ—Ç–∞ –ø–æ 5-–±–∞–ª–ª—å–Ω–æ–π —à–∫–∞–ª–µ:</b>

1 ‚≠ê - –£–∂–∞—Å–Ω–æ
2 ‚≠ê - –ü–ª–æ—Ö–æ  
3 ‚≠ê - –ù–æ—Ä–º–∞–ª—å–Ω–æ
4 ‚≠ê - –•–æ—Ä–æ—à–æ
5 ‚≠ê - –û—Ç–ª–∏—á–Ω–æ

<b>–í—ã–±–µ—Ä–∏—Ç–µ –æ—Ü–µ–Ω–∫—É:</b>
        """,
        "review"
    )
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("1 ‚≠ê", callback_data="review_1"),
        InlineKeyboardButton("2 ‚≠ê", callback_data="review_2"),
        InlineKeyboardButton("3 ‚≠ê", callback_data="review_3"),
        InlineKeyboardButton("4 ‚≠ê", callback_data="review_4"),
        InlineKeyboardButton("5 ‚≠ê", callback_data="review_5"),
        InlineKeyboardButton("‚¨ÖÔ∏è –ù–ê–ó–ê–î", callback_data="reviews_menu")
    ])
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

async def set_review_rating(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–µ–π—Ç–∏–Ω–≥–∞ –æ—Ç–∑—ã–≤–∞"""
    query = update.callback_query
    await query.answer()
    
    rating = int(query.data.split('_')[1])
    context.user_data['review_rating'] = rating
    
    text = styled_bot.format_message(
        "–ù–ê–ü–ò–°–ê–ù–ò–ï –û–¢–ó–´–í–ê",
        f"""
‚≠ê <b>–í—ã –≤—ã–±—Ä–∞–ª–∏ –æ—Ü–µ–Ω–∫—É: {rating}/5</b>

üìù –¢–µ–ø–µ—Ä—å –Ω–∞–ø–∏—à–∏—Ç–µ –≤–∞—à –æ—Ç–∑—ã–≤ (–º–∞–∫—Å–∏–º—É–º 500 —Å–∏–º–≤–æ–ª–æ–≤):

üí° <i>–†–∞—Å—Å–∫–∞–∂–∏—Ç–µ –æ –≤–∞—à–µ–º –æ–ø—ã—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞, —á—Ç–æ –ø–æ–Ω—Ä–∞–≤–∏–ª–æ—Å—å, —á—Ç–æ –º–æ–∂–Ω–æ —É–ª—É—á—à–∏—Ç—å.</i>
        """,
        "review"
    )
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("‚¨ÖÔ∏è –ù–ê–ó–ê–î", callback_data="leave_review")
    ])
    
    await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)

async def handle_review_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ –æ—Ç–∑—ã–≤–∞"""
    if not context.user_data.get('leaving_review'):
        return
    
    review_text = update.message.text
    rating = context.user_data.get('review_rating', 0)
    user = update.effective_user
    
    if len(review_text) > 500:
        await update.message.reply_text("‚ùå –û—Ç–∑—ã–≤ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π! –ú–∞–∫—Å–∏–º—É–º 500 —Å–∏–º–≤–æ–ª–æ–≤.")
        return
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç–∑—ã–≤
    success = review_system.add_review(
        user.id, 
        user.first_name, 
        rating, 
        review_text
    )
    
    if success:
        # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        context.user_data.pop('leaving_review', None)
        context.user_data.pop('review_rating', None)
        
        text = styled_bot.format_message(
            "–û–¢–ó–´–í –°–û–•–†–ê–ù–ï–ù!",
            f"""
‚úÖ <b>–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à –æ—Ç–∑—ã–≤!</b>

‚≠ê –û—Ü–µ–Ω–∫–∞: {rating}/5
üìù –û—Ç–∑—ã–≤: {review_text}

üí´ –í–∞—à–µ –º–Ω–µ–Ω–∏–µ –æ—á–µ–Ω—å –≤–∞–∂–Ω–æ –¥–ª—è –Ω–∞—Å!
            """,
            "success"
        )
    else:
        text = styled_bot.format_message(
            "–û–®–ò–ë–ö–ê",
            "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –æ—Ç–∑—ã–≤–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
            "danger"
        )
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("üìä –í–°–ï –û–¢–ó–´–í–´", callback_data="view_reviews"),
        InlineKeyboardButton("‚≠ê –ï–©–ï –û–¢–ó–´–í", callback_data="leave_review"),
        InlineKeyboardButton("‚¨ÖÔ∏è –ì–õ–ê–í–ù–ê–Ø", callback_data="back_main")
    ])
    
    await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

async def view_reviews(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü—Ä–æ—Å–º–æ—Ç—Ä –æ—Ç–∑—ã–≤–æ–≤"""
    query = update.callback_query
    if query:
        await query.answer()
    
    reviews = review_system.get_approved_reviews(10)
    stats = review_system.get_reviews_stats()
    total_reviews, avg_rating, five_stars = stats
    
    if not reviews:
        text = styled_bot.format_message(
            "–û–¢–ó–´–í–´",
            "üìù –ü–æ–∫–∞ –Ω–µ—Ç –æ—Ç–∑—ã–≤–æ–≤. –ë—É–¥—å—Ç–µ –ø–µ—Ä–≤—ã–º!",
            "review"
        )
    else:
        text = styled_bot.format_message(
            "–ü–û–°–õ–ï–î–ù–ò–ï –û–¢–ó–´–í–´",
            f"""
‚≠ê <b>–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>
üìä –û—Ç–∑—ã–≤–æ–≤: {total_reviews} | üèÜ –†–µ–π—Ç–∏–Ω–≥: {avg_rating:.1f}/5

<b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ –æ—Ç–∑—ã–≤—ã:</b>
            """,
            "review"
        )
        
        for i, (username, rating, comment, timestamp) in enumerate(reviews[:5], 1):
            stars = '‚≠ê' * rating
            date = datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S').strftime('%d.%m.%Y')
            text += f"\n{i}. {stars}\n"
            text += f"   üë§ {username}\n"
            text += f"   üìù {comment}\n"
            text += f"   üìÖ {date}\n"
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("‚≠ê –û–°–¢–ê–í–ò–¢–¨ –û–¢–ó–´–í", callback_data="leave_review"),
        InlineKeyboardButton("‚úçÔ∏è –ú–û–ô –û–¢–ó–´–í", callback_data="my_review"),
        InlineKeyboardButton("‚¨ÖÔ∏è –ù–ê–ó–ê–î", callback_data="reviews_menu")
    ])
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

async def my_review(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü—Ä–æ—Å–º–æ—Ç—Ä —Å–≤–æ–µ–≥–æ –æ—Ç–∑—ã–≤–∞"""
    query = update.callback_query
    if query:
        await query.answer()
    
    user = update.effective_user
    review = review_system.get_user_review(user.id)
    
    if not review:
        text = styled_bot.format_message(
            "–í–ê–® –û–¢–ó–´–í",
            "üìù –£ –≤–∞—Å –µ—â–µ –Ω–µ—Ç –æ—Ç–∑—ã–≤–æ–≤.\n\n–•–æ—Ç–∏—Ç–µ –æ—Å—Ç–∞–≤–∏—Ç—å –ø–µ—Ä–≤—ã–π –æ—Ç–∑—ã–≤?",
            "review"
        )
    else:
        rating, comment, timestamp = review
        stars = '‚≠ê' * rating
        date = datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S').strftime('%d.%m.%Y %H:%M')
        
        text = styled_bot.format_message(
            "–í–ê–® –û–¢–ó–´–í",
            f"""
{stars}

üìù <b>–í–∞—à –æ—Ç–∑—ã–≤:</b>
{comment}

üìÖ <b>–î–∞—Ç–∞:</b> {date}

üí´ –°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à –≤–∫–ª–∞–¥!
            """,
            "review"
        )
    
    keyboard = styled_bot.create_death_note_keyboard([
        InlineKeyboardButton("‚≠ê –û–°–¢–ê–í–ò–¢–¨ –û–¢–ó–´–í", callback_data="leave_review"),
        InlineKeyboardButton("‚úèÔ∏è –ò–ó–ú–ï–ù–ò–¢–¨ –û–¢–ó–´–í", callback_data="leave_review"),
        InlineKeyboardButton("üìä –í–°–ï –û–¢–ó–´–í–´", callback_data="view_reviews"),
        InlineKeyboardButton("‚¨ÖÔ∏è –ù–ê–ó–ê–î", callback_data="reviews_menu")
    ])
    
    if query:
        await query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)

# ==================== –û–ë–†–ê–ë–û–¢–ß–ò–ö –ö–ù–û–ü–û–ö ====================
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—Å–µ—Ö –∫–Ω–æ–ø–æ–∫"""
    query = update.callback_query
    await query.answer()
    
    user_id = update.effective_user.id
    command = query.data
    start_time = datetime.now()
    
    try:
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥
        if query.data == "back_main":
            await start(update, context)
        elif query.data == "analysis_menu":
            await analysis_menu(update, context)
        elif query.data == "game_menu":
            await enhanced_light_coin_menu(update, context)
        elif query.data == "help":
            await help_command(update, context)
        elif query.data == "nft_market":
            await nft_marketplace_command(update, context)
        elif query.data == "my_stars":
            await my_stars_command(update, context)
        elif query.data == "my_nfts":
            await my_nfts_command(update, context)
        elif query.data == "market_overview":
            await market_overview(update, context)
        elif query.data == "trending":
            await trending_coins(update, context)
        elif query.data.startswith("analyze_"):
            await comprehensive_analysis(update, context)
        elif query.data == "light_write":
            await light_write_action(update, context)
        elif query.data == "light_eliminate":
            await light_eliminate_menu(update, context)
        elif query.data.startswith("eliminate_"):
            await light_eliminate_action(update, context)
        elif query.data == "light_status":
            await light_status(update, context)
        elif query.data == "light_leaderboard":
            await light_leaderboard(update, context)
        elif query.data == "light_market":
            await light_market(update, context)
        # –ù–æ–≤—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –æ—Ç–∑—ã–≤–æ–≤
        elif query.data == "reviews_menu":
            await reviews_menu(update, context)
        elif query.data == "leave_review":
            await leave_review_start(update, context)
        elif query.data.startswith("review_"):
            await set_review_rating(update, context)
        elif query.data == "view_reviews":
            await view_reviews(update, context)
        elif query.data == "my_review":
            await my_review(update, context)
        
        # –õ–æ–≥–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
        response_time = (datetime.now() - start_time).total_seconds()
        learning_system.log_command_usage(command, user_id, response_time, True)
        
    except Exception as e:
        # –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É
        response_time = (datetime.now() - start_time).total_seconds()
        learning_system.log_command_usage(command, user_id, response_time, False)
        logger.error(f"–û—à–∏–±–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ –∫–Ω–æ–ø–æ–∫: {e}")

# ==================== –ö–û–ú–ê–ù–î–´ ====================
async def analysis_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /analysis"""
    await analysis_menu(update, context)

async def game_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /game"""
    await enhanced_light_coin_menu(update, context)

async def nft_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /nft"""
    await nft_marketplace_command(update, context)

async def mystars_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /mystars"""
    await my_stars_command(update, context)

async def mynfts_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /mynfts"""
    await my_nfts_command(update, context)

async def bitcoin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /bitcoin"""
    await comprehensive_analysis(update, context, 'bitcoin')

async def ethereum_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /ethereum"""
    await comprehensive_analysis(update, context, 'ethereum')

async def solana_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /solana"""
    await comprehensive_analysis(update, context, 'solana')

async def market_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /market"""
    await market_overview(update, context)

async def trending_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /trending"""
    await trending_coins(update, context)

async def write_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /write"""
    await light_write_action(update, context)

async def mystats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /mystats"""
    await light_status(update, context)

async def targets_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /targets"""
    await light_eliminate_menu(update, context)

async def leaderboard_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /leaderboard"""
    await light_leaderboard(update, context)

async def lightmarket_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /lightmarket"""
    await light_market(update, context)

# –ù–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞ –æ—Ç–∑—ã–≤–æ–≤
async def reviews_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–º–∞–Ω–¥–∞ /reviews"""
    await reviews_menu(update, context)

# ==================== –ó–ê–ü–£–°–ö –ë–û–¢–ê ====================
def main():
    """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
    try:
        application = Application.builder().token(BOT_TOKEN).build()
        
        # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∫–æ–º–∞–Ω–¥
        application.add_handler(CommandHandler("start", start))
        application.add_handler(CommandHandler("help", help_command))
        application.add_handler(CommandHandler("analysis", analysis_command))
        application.add_handler(CommandHandler("game", game_command))
        application.add_handler(CommandHandler("nft", nft_command))
        application.add_handler(CommandHandler("mystars", mystars_command))
        application.add_handler(CommandHandler("mynfts", mynfts_command))
        application.add_handler(CommandHandler("bitcoin", bitcoin_command))
        application.add_handler(CommandHandler("ethereum", ethereum_command))
        application.add_handler(CommandHandler("solana", solana_command))
        application.add_handler(CommandHandler("market", market_command))
        application.add_handler(CommandHandler("trending", trending_command))
        application.add_handler(CommandHandler("write", write_command))
        application.add_handler(CommandHandler("mystats", mystats_command))
        application.add_handler(CommandHandler("targets", targets_command))
        application.add_handler(CommandHandler("leaderboard", leaderboard_command))
        application.add_handler(CommandHandler("lightmarket", lightmarket_command))
        # –ù–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞ –æ—Ç–∑—ã–≤–æ–≤
        application.add_handler(CommandHandler("reviews", reviews_command))
        
        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫
        application.add_handler(CallbackQueryHandler(button_handler))
        
        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –æ—Ç–∑—ã–≤–æ–≤
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_review_text))
        
        print("üîÆ –ë–æ—Ç '–¢–µ—Ç—Ä–∞–¥—å –°–º–µ—Ä—Ç–∏' –∑–∞–ø—É—â–µ–Ω!")
        print("üìä –£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑: –ê–ö–¢–ò–í–ï–ù")
        print("üéÆ –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –∏–≥—Ä–∞: –ê–ö–¢–ò–í–ù–ê")
        print("üé¥ NFT —Å–∏—Å—Ç–µ–º–∞: –ê–ö–¢–ò–í–ù–ê")
        print("‚≠ê –°–∏—Å—Ç–µ–º–∞ –æ—Ç–∑—ã–≤–æ–≤: –ê–ö–¢–ò–í–ù–ê")
        print("ü§ñ –°–∏—Å—Ç–µ–º–∞ —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è: –ê–ö–¢–ò–í–ù–ê")
        print("üé® –°—Ç–∏–ª—å: Death Note")
        print("‚ö° –ö–æ–º–∞–Ω–¥—ã: /start, /game, /analysis, /nft, /reviews, /help")
        print("üîó –ù–∞–ø–∏—à–∏—Ç–µ /start –≤ Telegram")
        
        application.run_polling()
        
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞: {e}")

if __name__ == '__main__':
    main()